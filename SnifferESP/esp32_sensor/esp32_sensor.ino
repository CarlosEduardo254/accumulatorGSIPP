/*
 * ESP32 Sensor - Vers√£o Simplificada (SEM TinyCBOR)
 * Cria pacote CBOR manualmente
 */

#include <WiFi.h>
#include <WiFiUdp.h>

// ============================================
// CONFIGURA√á√ïES
// ============================================

const char* WIFI_SSID = "NEIKLOTDRADE 42140";
const char* WIFI_PASSWORD = "oirtnghkpodnfhdjfgjgkgkkhjhl4g5j4fg85.4j58h486h4j854hg8jhk";
const char* SERVER_IP = "192.168.137.1";  // ‚ö†Ô∏è AJUSTE SEU IP
const uint16_t SERVER_PORT = 4242;
const char* SENSOR_ID = "ESP-42";
const uint32_t SEND_INTERVAL_MS = 3000;

// ============================================
// MEMBERSHIP PROOF
// ============================================

const uint8_t MEMBERSHIP_PROOF[] PROGMEM = {
  0xA2, 0x67, 0x77, 0x69, 0x74, 0x6E, 0x65, 0x73, 0x73, 0xA2, 0x67, 0x70,
  0x68, 0x61, 0x6E, 0x74, 0x6F, 0x6D, 0xF6, 0x65, 0x76, 0x61, 0x6C, 0x75,
  0x65, 0x79, 0x02, 0x00, 0x35, 0x33, 0x37, 0x66, 0x34, 0x62, 0x35, 0x37,
  0x33, 0x33, 0x36, 0x36, 0x64, 0x33, 0x38, 0x31, 0x62, 0x62, 0x39, 0x33,
  0x37, 0x38, 0x63, 0x38, 0x61, 0x62, 0x37, 0x64, 0x66, 0x66, 0x35, 0x33,
  0x63, 0x30, 0x35, 0x38, 0x33, 0x34, 0x37, 0x32, 0x34, 0x36, 0x32, 0x37,
  0x34, 0x65, 0x62, 0x64, 0x36, 0x66, 0x30, 0x38, 0x31, 0x62, 0x62, 0x34,
  0x30, 0x32, 0x66, 0x35, 0x31, 0x39, 0x63, 0x30, 0x32, 0x38, 0x38, 0x31,
  0x31, 0x64, 0x37, 0x62, 0x64, 0x64, 0x66, 0x38, 0x33, 0x39, 0x36, 0x33,
  0x66, 0x30, 0x34, 0x65, 0x63, 0x39, 0x34, 0x66, 0x32, 0x61, 0x66, 0x31,
  0x63, 0x64, 0x63, 0x63, 0x66, 0x38, 0x37, 0x36, 0x35, 0x36, 0x36, 0x33,
  0x66, 0x34, 0x31, 0x61, 0x39, 0x32, 0x36, 0x38, 0x32, 0x64, 0x37, 0x34,
  0x66, 0x65, 0x34, 0x62, 0x32, 0x38, 0x37, 0x32, 0x36, 0x34, 0x66, 0x37,
  0x66, 0x32, 0x30, 0x34, 0x62, 0x63, 0x39, 0x35, 0x35, 0x36, 0x66, 0x61,
  0x31, 0x30, 0x34, 0x33, 0x33, 0x39, 0x37, 0x31, 0x38, 0x37, 0x30, 0x66,
  0x38, 0x36, 0x36, 0x66, 0x37, 0x39, 0x62, 0x65, 0x64, 0x61, 0x62, 0x39,
  0x37, 0x36, 0x63, 0x36, 0x65, 0x38, 0x37, 0x35, 0x65, 0x61, 0x66, 0x65,
  0x61, 0x37, 0x31, 0x33, 0x39, 0x61, 0x61, 0x38, 0x64, 0x64, 0x32, 0x32,
  0x64, 0x38, 0x37, 0x62, 0x32, 0x35, 0x38, 0x36, 0x63, 0x30, 0x66, 0x36,
  0x36, 0x62, 0x34, 0x33, 0x32, 0x31, 0x62, 0x36, 0x65, 0x35, 0x66, 0x34,
  0x32, 0x34, 0x31, 0x66, 0x38, 0x38, 0x30, 0x33, 0x31, 0x30, 0x31, 0x65,
  0x38, 0x34, 0x34, 0x62, 0x31, 0x34, 0x30, 0x39, 0x62, 0x33, 0x64, 0x64,
  0x63, 0x36, 0x31, 0x37, 0x30, 0x37, 0x33, 0x63, 0x32, 0x63, 0x65, 0x61,
  0x33, 0x33, 0x30, 0x34, 0x32, 0x39, 0x36, 0x62, 0x64, 0x32, 0x38, 0x39,
  0x30, 0x62, 0x61, 0x31, 0x32, 0x62, 0x66, 0x32, 0x37, 0x38, 0x34, 0x34,
  0x66, 0x35, 0x33, 0x31, 0x31, 0x34, 0x33, 0x39, 0x32, 0x39, 0x32, 0x35,
  0x65, 0x63, 0x66, 0x32, 0x32, 0x61, 0x32, 0x63, 0x33, 0x38, 0x35, 0x38,
  0x31, 0x39, 0x35, 0x37, 0x65, 0x63, 0x33, 0x33, 0x64, 0x62, 0x31, 0x39,
  0x34, 0x63, 0x37, 0x65, 0x63, 0x33, 0x64, 0x61, 0x32, 0x36, 0x63, 0x63,
  0x32, 0x66, 0x64, 0x38, 0x30, 0x35, 0x39, 0x33, 0x37, 0x38, 0x61, 0x33,
  0x35, 0x39, 0x37, 0x36, 0x65, 0x35, 0x63, 0x61, 0x37, 0x35, 0x65, 0x35,
  0x30, 0x38, 0x32, 0x64, 0x36, 0x61, 0x36, 0x65, 0x32, 0x36, 0x64, 0x33,
  0x64, 0x33, 0x33, 0x31, 0x64, 0x32, 0x38, 0x38, 0x39, 0x65, 0x39, 0x64,
  0x66, 0x30, 0x66, 0x66, 0x64, 0x31, 0x39, 0x32, 0x61, 0x62, 0x65, 0x66,
  0x36, 0x36, 0x31, 0x64, 0x35, 0x38, 0x64, 0x34, 0x37, 0x34, 0x37, 0x61,
  0x38, 0x35, 0x36, 0x66, 0x65, 0x31, 0x62, 0x61, 0x37, 0x34, 0x64, 0x39,
  0x36, 0x38, 0x61, 0x36, 0x33, 0x63, 0x31, 0x66, 0x64, 0x39, 0x65, 0x64,
  0x35, 0x33, 0x31, 0x39, 0x62, 0x33, 0x39, 0x37, 0x62, 0x38, 0x65, 0x64,
  0x39, 0x38, 0x37, 0x30, 0x30, 0x36, 0x30, 0x31, 0x66, 0x34, 0x38, 0x36,
  0x31, 0x31, 0x39, 0x38, 0x62, 0x34, 0x64, 0x39, 0x32, 0x34, 0x39, 0x33,
  0x30, 0x35, 0x66, 0x30, 0x61, 0x61, 0x31, 0x30, 0x31, 0x63, 0x39, 0x31,
  0x33, 0x61, 0x33, 0x64, 0x34, 0x31, 0x32, 0x62, 0x33, 0x32, 0x39, 0x34,
  0x37, 0x61, 0x61, 0x34, 0x38, 0x36, 0x36, 0x66, 0x35, 0x38, 0x66, 0x65,
  0x38, 0x64, 0x34, 0x61, 0x33, 0x63, 0x39, 0x30, 0x37, 0x65, 0x62, 0x37,
  0x61, 0x63, 0x34, 0x31, 0x37, 0x62, 0x65, 0x38, 0x38, 0x63, 0x37, 0x64,
  0x65, 0x70, 0x72, 0x6F, 0x6F, 0x66, 0xA1, 0x61, 0x51, 0x79, 0x02, 0x00,
  0x35, 0x33, 0x37, 0x66, 0x34, 0x62, 0x35, 0x37, 0x33, 0x33, 0x36, 0x36,
  0x64, 0x33, 0x38, 0x31, 0x62, 0x62, 0x39, 0x33, 0x37, 0x38, 0x63, 0x38,
  0x61, 0x62, 0x37, 0x64, 0x66, 0x66, 0x35, 0x33, 0x63, 0x30, 0x35, 0x38,
  0x33, 0x34, 0x37, 0x32, 0x34, 0x36, 0x32, 0x37, 0x34, 0x65, 0x62, 0x64,
  0x36, 0x66, 0x30, 0x38, 0x31, 0x62, 0x62, 0x34, 0x30, 0x32, 0x66, 0x35,
  0x31, 0x39, 0x63, 0x30, 0x32, 0x38, 0x38, 0x31, 0x31, 0x64, 0x37, 0x62,
  0x64, 0x64, 0x66, 0x38, 0x33, 0x39, 0x36, 0x33, 0x66, 0x30, 0x34, 0x65,
  0x63, 0x39, 0x34, 0x66, 0x32, 0x61, 0x66, 0x31, 0x63, 0x64, 0x63, 0x63,
  0x66, 0x38, 0x37, 0x36, 0x35, 0x36, 0x36, 0x33, 0x66, 0x34, 0x31, 0x61,
  0x39, 0x32, 0x36, 0x38, 0x32, 0x64, 0x37, 0x34, 0x66, 0x65, 0x34, 0x62,
  0x32, 0x38, 0x37, 0x32, 0x36, 0x34, 0x66, 0x37, 0x66, 0x32, 0x30, 0x34,
  0x62, 0x63, 0x39, 0x35, 0x35, 0x36, 0x66, 0x61, 0x31, 0x30, 0x34, 0x33,
  0x33, 0x39, 0x37, 0x31, 0x38, 0x37, 0x30, 0x66, 0x38, 0x36, 0x36, 0x66,
  0x37, 0x39, 0x62, 0x65, 0x64, 0x61, 0x62, 0x39, 0x37, 0x36, 0x63, 0x36,
  0x65, 0x38, 0x37, 0x35, 0x65, 0x61, 0x66, 0x65, 0x61, 0x37, 0x31, 0x33,
  0x39, 0x61, 0x61, 0x38, 0x64, 0x64, 0x32, 0x32, 0x64, 0x38, 0x37, 0x62,
  0x32, 0x35, 0x38, 0x36, 0x63, 0x30, 0x66, 0x36, 0x36, 0x62, 0x34, 0x33,
  0x32, 0x31, 0x62, 0x36, 0x65, 0x35, 0x66, 0x34, 0x32, 0x34, 0x31, 0x66,
  0x38, 0x38, 0x30, 0x33, 0x31, 0x30, 0x31, 0x65, 0x38, 0x34, 0x34, 0x62,
  0x31, 0x34, 0x30, 0x39, 0x62, 0x33, 0x64, 0x64, 0x63, 0x36, 0x31, 0x37,
  0x30, 0x37, 0x33, 0x63, 0x32, 0x63, 0x65, 0x61, 0x33, 0x33, 0x30, 0x34,
  0x32, 0x39, 0x36, 0x62, 0x64, 0x32, 0x38, 0x39, 0x30, 0x62, 0x61, 0x31,
  0x32, 0x62, 0x66, 0x32, 0x37, 0x38, 0x34, 0x34, 0x66, 0x35, 0x33, 0x31,
  0x31, 0x34, 0x33, 0x39, 0x32, 0x39, 0x32, 0x35, 0x65, 0x63, 0x66, 0x32,
  0x32, 0x61, 0x32, 0x63, 0x33, 0x38, 0x35, 0x38, 0x31, 0x39, 0x35, 0x37,
  0x65, 0x63, 0x33, 0x33, 0x64, 0x62, 0x31, 0x39, 0x34, 0x63, 0x37, 0x65,
  0x63, 0x33, 0x64, 0x61, 0x32, 0x36, 0x63, 0x63, 0x32, 0x66, 0x64, 0x38,
  0x30, 0x35, 0x39, 0x33, 0x37, 0x38, 0x61, 0x33, 0x35, 0x39, 0x37, 0x36,
  0x65, 0x35, 0x63, 0x61, 0x37, 0x35, 0x65, 0x35, 0x30, 0x38, 0x32, 0x64,
  0x36, 0x61, 0x36, 0x65, 0x32, 0x36, 0x64, 0x33, 0x64, 0x33, 0x33, 0x31,
  0x64, 0x32, 0x38, 0x38, 0x39, 0x65, 0x39, 0x64, 0x66, 0x30, 0x66, 0x66,
  0x64, 0x31, 0x39, 0x32, 0x61, 0x62, 0x65, 0x66, 0x36, 0x36, 0x31, 0x64,
  0x35, 0x38, 0x64, 0x34, 0x37, 0x34, 0x37, 0x61, 0x38, 0x35, 0x36, 0x66,
  0x65, 0x31, 0x62, 0x61, 0x37, 0x34, 0x64, 0x39, 0x36, 0x38, 0x61, 0x36,
  0x33, 0x63, 0x31, 0x66, 0x64, 0x39, 0x65, 0x64, 0x35, 0x33, 0x31, 0x39,
  0x62, 0x33, 0x39, 0x37, 0x62, 0x38, 0x65, 0x64, 0x39, 0x38, 0x37, 0x30,
  0x30, 0x36, 0x30, 0x31, 0x66, 0x34, 0x38, 0x36, 0x31, 0x31, 0x39, 0x38,
  0x62, 0x34, 0x64, 0x39, 0x32, 0x34, 0x39, 0x33, 0x30, 0x35, 0x66, 0x30,
  0x61, 0x61, 0x31, 0x30, 0x31, 0x63, 0x39, 0x31, 0x33, 0x61, 0x33, 0x64,
  0x34, 0x31, 0x32, 0x62, 0x33, 0x32, 0x39, 0x34, 0x37, 0x61, 0x61, 0x34,
  0x38, 0x36, 0x36, 0x66, 0x35, 0x38, 0x66, 0x65, 0x38, 0x64, 0x34, 0x61,
  0x33, 0x63, 0x39, 0x30, 0x37, 0x65, 0x62, 0x37, 0x61, 0x63, 0x34, 0x31,
  0x37, 0x62, 0x65, 0x38, 0x38, 0x63, 0x37, 0x64
};
const size_t PROOF_SIZE = 1064;

// ============================================
// VARI√ÅVEIS GLOBAIS
// ============================================

WiFiUDP udp;
uint64_t packetCounter = 0;

// ============================================
// FUN√á√ïES CBOR MANUAIS
// ============================================

class SimpleCBOR {
private:
  uint8_t* buffer;
  size_t pos;
  size_t maxSize;

public:
  SimpleCBOR(uint8_t* buf, size_t size) : buffer(buf), pos(0), maxSize(size) {}

  void writeMap(uint8_t numPairs) {
    buffer[pos++] = 0xA0 | numPairs;  // Map com N pares
  }

  void writeString(const char* str) {
    size_t len = strlen(str);
    if (len < 24) {
      buffer[pos++] = 0x60 | len;  // String curta
    } else {
      buffer[pos++] = 0x78;  // String de 1 byte de tamanho
      buffer[pos++] = len;
    }
    memcpy(&buffer[pos], str, len);
    pos += len;
  }

  void writeUint64(uint64_t value) {
    if (value < 24) {
      buffer[pos++] = value;
    } else if (value <= 0xFF) {
      buffer[pos++] = 0x18;
      buffer[pos++] = value;
    } else if (value <= 0xFFFF) {
      buffer[pos++] = 0x19;
      buffer[pos++] = (value >> 8) & 0xFF;
      buffer[pos++] = value & 0xFF;
    } else if (value <= 0xFFFFFFFF) {
      buffer[pos++] = 0x1A;
      buffer[pos++] = (value >> 24) & 0xFF;
      buffer[pos++] = (value >> 16) & 0xFF;
      buffer[pos++] = (value >> 8) & 0xFF;
      buffer[pos++] = value & 0xFF;
    } else {
      buffer[pos++] = 0x1B;
      for (int i = 7; i >= 0; i--) {
        buffer[pos++] = (value >> (i * 8)) & 0xFF;
      }
    }
  }

  void writeBytes(const uint8_t* data, size_t len) {
    if (len < 24) {
      buffer[pos++] = 0x40 | len;  // Byte string curta
    } else if (len <= 0xFF) {
      buffer[pos++] = 0x58;  // Byte string de 1 byte de tamanho
      buffer[pos++] = len;
    } else {
      buffer[pos++] = 0x59;  // Byte string de 2 bytes
      buffer[pos++] = (len >> 8) & 0xFF;
      buffer[pos++] = len & 0xFF;
    }
    memcpy(&buffer[pos], data, len);
    pos += len;
  }

  size_t getSize() { return pos; }
};

// ============================================
// FUN√á√ïES
// ============================================

void connectWiFi() {
  Serial.println("\nüì° Conectando ao WiFi...");
  Serial.printf("   SSID: %s\n", WIFI_SSID);

  WiFi.mode(WIFI_STA);
  WiFi.begin(WIFI_SSID, WIFI_PASSWORD);

  uint8_t attempts = 0;
  while (WiFi.status() != WL_CONNECTED && attempts < 30) {
    delay(500);
    Serial.print(".");
    attempts++;
  }

  if (WiFi.status() == WL_CONNECTED) {
    Serial.println("\n‚úÖ WiFi conectado!");
    Serial.printf("   IP: %s\n", WiFi.localIP().toString().c_str());
    Serial.printf("   Servidor: %s:%d\n", SERVER_IP, SERVER_PORT);
  } else {
    Serial.println("\n‚ùå Falha WiFi!");
  }
}

void sendPacket() {
  uint8_t cborBuffer[2048];  // Buffer maior para seguran√ßa
  SimpleCBOR cbor(cborBuffer, sizeof(cborBuffer));

  // Criar mapa com 4 campos
  cbor.writeMap(4);

  // Campo "1": ID
  cbor.writeString("1");
  cbor.writeString(SENSOR_ID);

  // Campo "2": Timestamp
  cbor.writeString("2");
  cbor.writeUint64((uint64_t)millis());

  // Campo "3": Counter
  cbor.writeString("3");
  packetCounter++;
  cbor.writeUint64(packetCounter);

  // Campo "4": Proof
  cbor.writeString("4");
  cbor.writeBytes(MEMBERSHIP_PROOF, PROOF_SIZE);

  size_t cborSize = cbor.getSize();

  // Enviar UDP
  IPAddress serverAddr;
  serverAddr.fromString(SERVER_IP);

  udp.beginPacket(serverAddr, SERVER_PORT);
  size_t sent = udp.write(cborBuffer, cborSize);
  bool success = udp.endPacket();

  if (success && sent == cborSize) {
    Serial.printf("‚úÖ [%lu] Enviado: %d bytes | Counter: %llu\n",
                  millis(), cborSize, packetCounter);
  } else {
    Serial.printf("‚ùå Erro no envio (%d/%d bytes)\n", sent, cborSize);
  }
}

// ============================================
// SETUP
// ============================================

void setup() {
  Serial.begin(115200);
  delay(500);

  Serial.println("\n‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  Serial.println("  ESP32 Sensor - Vers√£o Simplificada");
  Serial.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê");
  Serial.printf(" Sensor ID: %s\n", SENSOR_ID);
  Serial.printf(" Proof: %d bytes\n", PROOF_SIZE);
  Serial.println("‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê\n");

  connectWiFi();

  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ùå ERRO: WiFi n√£o conectado!");
    while (1) delay(1000);
  }

  Serial.println("\n‚úÖ Pronto! Enviando pacotes...\n");
  delay(1000);
}

// ============================================
// LOOP
// ============================================

void loop() {
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("‚ö†Ô∏è WiFi desconectado!");
    connectWiFi();
  }

  if (WiFi.status() == WL_CONNECTED) {
    sendPacket();
  }

  delay(SEND_INTERVAL_MS);
}
